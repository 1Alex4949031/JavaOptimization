# Task-1:
Нужно написать программу, которая в бесконечном цикле аллоцирует некоторый объект и периодически делает замеры: максимального объема доступной памяти, объема аллоцированной памяти и объема свободной памяти. На основе измерений нужно вычислить объем занятой памяти и построить график, содержащий четыре этих показателя.

Графики нужно будет продемонстрировать и объяснить все особенности поведения показателей - начальные и конечные точки, особенности изменения значений.

Далее - провести ряд экспериментов, различным образом модифицируя аллоцируемый в цикле объект. Например: добавляя поля различных типов. На основе этих экспериментов нужно будет сформулировать алгоритм вычисления занимаемой памяти некоторым объектом в Java. Конкретно интересуют накладные расходы на создание массива и класса

# Task-2:
Реализовать приложение-пример в котором будет:

- Класс с сигнлтоном
- Класс Bean с полем-именем, содежащий массив байт, ArrayList, примитивы и ссылку на себя.
- Несколько экземпляров класса Bean, замкнутых в кольцо своими ссылками.
- Несколько потоков, бесконечно висящих в sleep.
- Каждый поток имеет свою ссылку на сигнлтон и создает свой экземпляр класса Bean.
- "Вредный" поток, который ломает все по OutOfMemory, бесконечно аллоцируя массивы
- Вредный поток запускать специальным параметром командной строки

Затем скомпилировать и запуская приложение из консоли сделать следующее:

- прицепиться jmap-ом и сохранить дамп памяти
- рассказать, по каким признакам выпоймете, что какой-то файл является дампом памяти
- открыть дамп памяти с помощью Memory Analyzer Tool или IntelliJ Idea
- показать в дампе колько ссылок, синглтон, потоки и их переменные

- прицепиться jstack-ом и сохранить дамп потоков
- рассказать, по каким признакам выпоймете, что какой-то файл является дампом потоков
- показать в дампе потоков потоки приложения и в каком они были состоянии

- прицепиться jcmd и выполнить для примера пару его команд
- рассказать своими словами, для чего нужен jcmd и какие команды у него есть

- прицепиться jconsole и рассказать что где находится в интерфейсе

- запустить приложение с включенным "вредным" потоком и -XX:+HeapDumpOnOutOfMemoryError
  желательно сделать -Xmx чтобы дамп не был сильно большой
- дождаться когда приложение сломается и сохранит дамп памяти
- при необходимости использовать -Xmx (если долго ждать или дамп большой, например)
- открыть дамп памяти и рассказать, по каким признакам вы поймете, кто сожрал всю память

# Task-3: 
Изучить документацию про JNI, процесс разработки приложений с нативной частью.
Искать по ключевым словам: javah, JNI, gcc generate symbols (символы для расшифровки нативных крешей)

Создать Bean, в котором будут примитивные типы, строка, ссылка на Bean, массивы примитивных типов и объектов.

Сделать класс с native-методами и реализовать их:

- Метод который жрет память внутри C и роняет все
- Метод который аллоцирует 1 Кб памяти. Потом показать, как это видно из методов Runtime.xxxMemory()
- Метод, который внутри C вызывает друг за другом кучу других методов и где-то внутри ломается.
  Показать stack trace, рассказать как найти место поломки в коде
- Получить строку String и вернуть длину строки
- Получить объект и вызвать у него метод
- Получить объект и поменять значение его java-поля
- Сделать три метода для работы с нативными структурами данных:
  - Аллоцировать какую-то свою структуру, вернуть указатель
  - Получить указатель на структуру, вернуть значение изнутри структуры
  - Получить указатель и освободить память

# Task-4: 
Реализовать умножение матриц на Java и на Java-JNI-C. Матрицы хранить в структурах Java и C соответственно.
Заполнять матрицы случайными числами.

Замерить быстродействие для обоих вариантов. Замеры осуществить для матриц размером 128x128 и 1024x1024.
Измерить разницу с разными параметрами оптимизации C

# Task-5: 
Сделать класс со следующими методами:

- Получить в параметрах строку String и вернуть её длину
- Получить в параметрах объект, вызвать у него метод и вернуть значение
- Получить объект и поменять значение его java-поля

Посмотреть, как это выглядит в байт-коде

Рядом еще реализовать:

- Класс с полем value.
- Ручную сортировку объектов этого класса по возрастанию value любым способом
- В main - заполнение списка рандомными объектами этого класса, сортировку и распечатку списка

Затем скомпилировать, натравить "javap -c -v" и объяснить, что получилось в байт-коде.
Показать где какие циклы и где какие if-ы и вообще какой код во что преобразился.

Декомпилировать все с помощью recaf - показать полученный исходник.
Внести изменения в код с помощью recaf, показать что работает.

Ссылки:
- https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javap.html
- https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html
- https://github.com/Col-E/Recaf

# Task-6: 
- Взять сортировку из предыдущего задания
- Реализовать 5 пустых классов с 5 пустыми методами.
- Все скомпилировать, засунуть в jar

- Натравить proguard и сделать, чтобы:
  - Ничего не произошло
  - proguard сделал все что мог - все вырезал и обфусцировал
  - не трогал некоторые классы по имени
  - не трогал некоторые методы по имени
  - не трогал некоторые методы по сигнатуре

Потом посмотреть-показать что будет в javap и recaf

Ссылка: https://www.guardsquare.com/proguard
