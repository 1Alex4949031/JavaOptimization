------------------------------------------------------------------------------------------------
Задание:
------------------------------------------------------------------------------------------------
Реализовать приложение-пример в котором будет:

- Класс с сигнлтоном
- Класс Bean с полем-именем, содежащий массив байт, ArrayList, примитивы и ссылку на себя.
- Несколько экземпляров класса Bean, замкнутых в кольцо своими ссылками.
- Несколько потоков, бесконечно висящих в sleep.
- Каждый поток имеет свою ссылку на сигнлтон и создает свой экземпляр класса Bean.
- "Вредный" поток, который ломает все по OutOfMemory, бесконечно аллоцируя массивы
- Вредный поток запускать специальным параметром командной строки

Затем скомпилировать и запуская приложение из консоли сделать следующее:

- прицепиться jmap-ом и сохранить дамп памяти
- рассказать, по каким признакам выпоймете, что какой-то файл является дампом памяти
- открыть дамп памяти с помощью Memory Analyzer Tool или IntelliJ Idea
- показать в дампе колько ссылок, синглтон, потоки и их переменные

- прицепиться jstack-ом и сохранить дамп потоков
- рассказать, по каким признакам выпоймете, что какой-то файл является дампом потоков
- показать в дампе потоков потоки приложения и в каком они были состоянии

- прицепиться jcmd и выполнить для примера пару его команд
- рассказать своими словами, для чего нужен jcmd и какие команды у него есть

- прицепиться jconsole и рассказать что где находится в интерфейсе

- запустить приложение с включенным "вредным" потоком и -XX:+HeapDumpOnOutOfMemoryError
- дождаться когда приложение сломается и сохранит дамп памяти
- при необходимости использовать -Xmx (если долго ждать или дамп большой, например)
- открыть дамп памяти и рассказать, по каким признакам вы поймете, кто сожрал всю память

------------------------------------------------------------------------------------------------
Памятка:
------------------------------------------------------------------------------------------------
1)Компиляция
java -cp .\Lesson1Task.jar Main --bad

------------------------------------------------------------------------------------------------
2)Дамп памяти
Дамп памяти (Heap Dump) — это снимок содержимого памяти программы в определённый момент времени. Для Java-приложений это обычно включает в себя всю информацию о куче (heap), где хранятся объекты, используемые приложением, включая классы объектов, поля, примитивные типы и ссылки между объектами. Дамп памяти позволяет разработчикам и аналитикам подробно изучить состояние памяти приложения для выявления утечек памяти, определения объектов, занимающих большую часть памяти, и анализа взаимосвязей между объектами.
PID процесса смотрел через jps и visualVM (стороняя утилита)
jmap -dump:format=b,file=heapdump.hprof <PID>

------------------------------------------------------------------------------------------------
3) Дамп потоков
jstack <PID> > threadDump.txt
Дамп потоков содержит информацию о текущем состоянии всех потоков в JVM, включая стек вызовов для каждого потока. Файл дампа потоков обычно текстовый, его можно идентифицировать по наличию стеков вызовов и имен потоков.

------------------------------------------------------------------------------------------------
4) jcmd
jcmd — это утилита, предоставляющая средства для отправки команд управления и диагностики в JVM. Она может использоваться для выполнения различных операций, таких как сбор дампа памяти, дампа потоков, просмотр статистики использования памяти и выполнение GC.
Примеры команд:

Список всех запущенных JVM процессов: jcmd -l
Сбор дампа памяти: jcmd <PID> GC.heap_dump <filename>
Вывод статистики использования памяти: jcmd <PID> GC.class_histogram
Назначение jcmd:
jcmd предоставляет единый интерфейс для выполнения диагностических и управленческих команд, что делает его мощным инструментом для мониторинга и управления приложениями Java

1. Список запущенных JVM процессов
Для получения списка всех запущенных Java-процессов и их идентификаторов:

jcmd -l
2. Вывод информации о конфигурации JVM
Для вывода аргументов командной строки и системных свойств для запущенной JVM:

jcmd <PID> VM.flags
jcmd <PID> VM.system_properties
Здесь <PID> — идентификатор процесса JVM, для которого вы хотите получить информацию.

3. Вывод статистики использования кучи
Для вывода обзора использования кучи (heap):

jcmd <PID> GC.heap_info
4. Выполнение сборки мусора
Для инициирования сборки мусора в JVM:

jcmd <PID> GC.run
5. Создание дампа кучи
Для создания дампа кучи в файл:

jcmd <PID> GC.heap_dump <путь_к_файлу>
6. Вывод статистики классов
Для получения информации о загруженных классах и их использовании в куче:

jcmd <PID> GC.class_histogram
7. Вывод информации о потоках
Для получения информации о текущем состоянии потоков:

jcmd <PID> Thread.print
8. Вывод сведений о конфигурации и состоянии кодовых кэшей
Для просмотра информации о кодовых кэшах:

jcmd <PID> VM.code_cache
9. Динамическое изменение уровня логирования для различных подсистем JVM
Для изменения уровня логирования в реальном времени:

jcmd <PID> VM.log what=gc+heap=debug
10. Вывод сводной информации о JVM
Для получения сводной информации о JVM:

jcmd <PID> VM.info
Эти команды предоставляют широкий спектр возможностей для мониторинга и управления JVM, делая jcmd неоценимым инструментом для разработчиков и системных администраторов.

------------------------------------------------------------------------------------------------
5) jconsole
jconsole — это графический инструмент мониторинга, который позволяет визуализировать различные метрики JVM, такие как использование памяти, потребление CPU, потоки, классы и сборку мусора.

------------------------------------------------------------------------------------------------
6) Использовал Memory Leak Report.
Сразу обнаружил, кто сожрал всю память)
